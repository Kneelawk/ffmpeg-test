// Generated by jextract

package org.ffmpeg.libavformat;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
public class avformat_h  {

    public static final OfByte C_CHAR = JAVA_BYTE;
    public static final OfShort C_SHORT = JAVA_SHORT;
    public static final OfInt C_INT = JAVA_INT;
    public static final OfLong C_LONG = JAVA_LONG;
    public static final OfLong C_LONG_LONG = JAVA_LONG;
    public static final OfFloat C_FLOAT = JAVA_FLOAT;
    public static final OfDouble C_DOUBLE = JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = RuntimeHelper.POINTER;
    public static MethodHandle avformat_open_input$MH() {
        return RuntimeHelper.requireNonNull(constants$16.const$3,"avformat_open_input");
    }
    /**
     * {@snippet :
     * int avformat_open_input(AVFormatContext** ps, char* url, const AVInputFormat* fmt, AVDictionary** options);
     * }
     */
    public static int avformat_open_input(MemorySegment ps, MemorySegment url, MemorySegment fmt, MemorySegment options) {
        var mh$ = avformat_open_input$MH();
        try {
            return (int)mh$.invokeExact(ps, url, fmt, options);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle avformat_find_stream_info$MH() {
        return RuntimeHelper.requireNonNull(constants$16.const$4,"avformat_find_stream_info");
    }
    /**
     * {@snippet :
     * int avformat_find_stream_info(AVFormatContext* ic, AVDictionary** options);
     * }
     */
    public static int avformat_find_stream_info(MemorySegment ic, MemorySegment options) {
        var mh$ = avformat_find_stream_info$MH();
        try {
            return (int)mh$.invokeExact(ic, options);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle av_find_best_stream$MH() {
        return RuntimeHelper.requireNonNull(constants$16.const$6,"av_find_best_stream");
    }
    /**
     * {@snippet :
     * int av_find_best_stream(AVFormatContext* ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, struct AVCodec** decoder_ret, int flags);
     * }
     */
    public static int av_find_best_stream(MemorySegment ic, int type, int wanted_stream_nb, int related_stream, MemorySegment decoder_ret, int flags) {
        var mh$ = av_find_best_stream$MH();
        try {
            return (int)mh$.invokeExact(ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle avformat_close_input$MH() {
        return RuntimeHelper.requireNonNull(constants$17.const$1,"avformat_close_input");
    }
    /**
     * {@snippet :
     * void avformat_close_input(AVFormatContext** s);
     * }
     */
    public static void avformat_close_input(MemorySegment s) {
        var mh$ = avformat_close_input$MH();
        try {
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle av_dump_format$MH() {
        return RuntimeHelper.requireNonNull(constants$17.const$3,"av_dump_format");
    }
    /**
     * {@snippet :
     * void av_dump_format(AVFormatContext* ic, int index, char* url, int is_output);
     * }
     */
    public static void av_dump_format(MemorySegment ic, int index, MemorySegment url, int is_output) {
        var mh$ = av_dump_format$MH();
        try {
            mh$.invokeExact(ic, index, url, is_output);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
}


